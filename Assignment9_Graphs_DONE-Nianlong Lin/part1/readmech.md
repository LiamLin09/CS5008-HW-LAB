# 有向图和无向图
在上一次的作业中，你实现了一个被称为二叉搜索树(BST)的数据结构。在这次的作业中，我们将要实现另一个数据结构，即图。
树

作为提醒，我们已经研究过一种图的特殊情况——树。树是图的一个特殊实例，根据定义不能包含循环。树还有另一个名称——有向无环图(DAG)，这意味着它们是有向图。树包含节点（也称为顶点），这些节点指向它的子节点，显示了层次关系（即子节点不会指向父节点或祖父节点）。因此，在遍历树时，我们有一个根节点从中开始，我们可以遍历树的每个级别，到达每个子节点以查找其数据。

# 图
图更通用地是一种数据结构，可以模拟许多类型的关系。图可以具有循环，可以是有向的或无向的，并且每个边可以具有正数或负数权重。左侧的图是无向的，右侧的图是有向的。
 
在左侧的图中，我们可以从节点0到节点1，反之亦然。然而，在右侧的图中，我们可以从节点0到节点1，但不能直接从节点1到节点0，必须找到另一条路径（即访问节点2，然后访问节点0）。
就像在树中一样，在图中，节点被称为顶点，连接被称为边。

# 如何表示图
表示图的两种主要方法是：

1.邻接表（也称为邻居列表）
2.邻接矩阵（在本周的实验室课程中介绍）

# 邻接表
邻接表的基本思想是每个节点都存储其邻居的列表，而不像二叉搜索树（BST）那样只有一个左子节点和右子节点。
让我们重新看看我们的节点类，以了解如何实现邻接表：
// 这是我们用于BST的节点。
```c
typedef struct node {
    int data;
    struct node* leftChild;
    struct node* rightChild;
} node_t;
```
然而，我们的图节点（graph_node）不同，它的一个字段将是一个列表，其中包含我们指向的节点（出邻居）和指向我们的节点（入邻居）。
```c
typedef struct graph_node {
    int data;
    dll_t* out_neighbors;  // 指向的节点（出邻居）
    dll_t* in_neighbors;   // 指向我们的节点（入邻居）
} node_t;
```
所以，尽管我们之前学习过邻接矩阵，其中可以使用数组来存储邻居，但需要考虑的问题是：为什么这可能会有问题？一个答案是，您必须小心分配足够的空间来存储所有邻居。如果空间不足，您可能需要执行昂贵的复制操作（O(n)），如果有太多空间，您将浪费宝贵的内存。
对于graph_t结构，我们只需要存储所有邻居节点，可以将它们存储在一个双向链表中。

这段代码示例中，你介绍了一种在图（graph_t）数据结构中使用通用性的方法，通过将邻居节点存储在一个双向链表（dll_t）中，同时将链表节点的数据类型从int更改为void*。这允许你在链表中存储任何类型的指针，而不仅仅是graph_node_t*，实现了C语言数据结构中的通用性。
首先，你定义了一个新的链表节点结构（node_t）：
// 这是我们用于DLL实现的节点
```c
typedef struct node {
    void* data;  // 这是更改的部分，允许存储任何类型的指针
    struct node* next;
    struct node* prev;
} node_t;
```

现在，你可以在图的数据结构中存储任何类型的指针，而不仅仅是整数。
接下来，你展示了如何使用这种通用的链表结构来实现图的功能，例如添加节点（add_node）：
```c  
int add_node(graph_t* g, int data) {
    if (g == NULL) return -1;

    // 确保具有此数据的节点不已经在图中。
    // 你需要编写此功能。
    // 你必须搜索图节点的链表，查看是否已经存在一个具有这个数据的图节点。
    if (find_node(g, data) == 0) return -1;

    // 如果不存在，创建一个新的具有此数据的图节点。
    graph_node_t* newNode = createNewGraphNode(data); // 这是一个辅助函数，用于分配新的图节点并设置其数据字段。
    if (newNode == NULL) return -1;

    push_back(g-&gt;nodes, newNode); // 将新节点添加到图的节点链表中
    g-&gt;numNodes = g-&gt;numNodes + 1; // 更新图中节点的数量
}
```
注意，push_back是在双向链表中定义的函数。由于g-&gt;nodes是一个双向链表，你可以在此处调用push_back，实现了代码的复用和简化图的实现。
这种通用的链表结构使得能够在图中存储各种类型的数据，而不仅限于特定类型。这种通用性是C数据结构常用的技巧，可以使代码更加灵活和可重用。

# 待办事项
代码的结构已经为您提供。

您需要将以前任务中的双向链表（DLL）代码的每个函数粘贴到my_dll.h头文件中。请注意，函数签名已经为您更新。
本次任务的建议
由于这是一个比平常更长的任务，请在进行小的更改后经常编译。
确保您编写的每个小更改都经过编译并经过测试，然后再进行下一次更改。
在没有编译或测试的情况下编写大量代码，尤其是对于这个任务来说，很可能会引起问题。
编写遍历算法的提示
正如您在课堂上所看到的，当遍历图时，需要找到一种方法来确定节点是否已经被访问，以防止陷入无限循环。有两种方法可以解决这个问题：

在graph_node_t结构体中引入一个int visited字段，如果节点已经被访问则设置为1，否则设置为0。如果选择这种方法，需要在进行新的遍历之前重置每个节点中的visited标志为0。

您也可以使用一个dll_t来存储已经访问过的节点。

# 单元测试
单元测试是用来检查代码中特定用例的正确性的独立测试。在我们的情况下，我们正在测试我们的graph_t实现是否有效。
您应该编写单元测试来测试您的实现。